"""
GenBIæµ‹è¯•é—®é¢˜åŠ©æ‰‹
æä¾›å¿«é€Ÿæµ‹è¯•é—®é¢˜é€‰æ‹©å’Œæ‰§è¡ŒåŠŸèƒ½
"""

import streamlit as st
import random
from typing import Dict, List, Tuple

class TestQuestionHelper:
    """æµ‹è¯•é—®é¢˜åŠ©æ‰‹ç±»"""
    
    def __init__(self):
        self.questions = self._load_questions()
    
    def _load_questions(self) -> Dict[str, List[Tuple[int, str]]]:
        """åŠ è½½æµ‹è¯•é—®é¢˜"""
        return {
            "æ—¶é—´ç»´åº¦åˆ†æ": [
                (1, "å“ªä¸ªå­£èŠ‚çš„é”€å”®é¢æœ€é«˜ï¼Ÿå­£èŠ‚æ€§è¶‹åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ"),
                (2, "æœˆåº¦é”€å”®å¢é•¿ç‡å¦‚ä½•ï¼Ÿå“ªäº›æœˆä»½è¡¨ç°å¼‚å¸¸ï¼Ÿ"),
                (3, "å·¥ä½œæ—¥vså‘¨æœ«çš„é”€å”®æ¨¡å¼æœ‰ä»€ä¹ˆå·®å¼‚ï¼Ÿ"),
                (4, "2020-2025å¹´æœŸé—´ï¼Œå¹´åº¦é”€å”®å¤åˆå¢é•¿ç‡æ˜¯å¤šå°‘ï¼Ÿ"),
                (5, "èŠ‚å‡æ—¥å¯¹é”€å”®çš„å½±å“ç¨‹åº¦å¦‚ä½•ï¼Ÿ"),
            ],
            "äº§å“ç»´åº¦åˆ†æ": [
                (6, "å“ªäº›äº§å“æ˜¯ç•…é”€å“ï¼Ÿå“ªäº›æ˜¯æ»é”€å“ï¼Ÿ"),
                (7, "ä¸åŒäº§å“ç±»åˆ«çš„åˆ©æ¶¦ç‡æ’åå¦‚ä½•ï¼Ÿ"),
                (8, "äº§å“ç”Ÿå‘½å‘¨æœŸå„é˜¶æ®µçš„é”€å”®ç‰¹å¾æ˜¯ä»€ä¹ˆï¼Ÿ"),
                (9, "å“ªäº›äº§å“ç»„åˆç»å¸¸ä¸€èµ·è´­ä¹°ï¼Ÿ"),
                (10, "äº§å“ä»·æ ¼æ•æ„Ÿæ€§åˆ†æï¼šæ¶¨ä»·å¯¹é”€é‡çš„å½±å“ï¼Ÿ"),
            ],
            "å®¢æˆ·ä»·å€¼åˆ†æ": [
                (11, "å®¢æˆ·çš„RFMåˆ†æç»“æœå¦‚ä½•ï¼Ÿï¼ˆæœ€è¿‘æ¶ˆè´¹ã€é¢‘ç‡ã€é‡‘é¢ï¼‰"),
                (12, "é«˜ä»·å€¼å®¢æˆ·çš„ç‰¹å¾å’Œè¡Œä¸ºæ¨¡å¼æ˜¯ä»€ä¹ˆï¼Ÿ"),
                (13, "å®¢æˆ·æµå¤±é¢„è­¦ï¼šå“ªäº›å®¢æˆ·æœ‰æµå¤±é£é™©ï¼Ÿ"),
                (14, "æ–°å®¢æˆ·è·å–æˆæœ¬vsè€å®¢æˆ·ç»´æŠ¤æˆæœ¬å¯¹æ¯”ï¼Ÿ"),
                (15, "ä¸åŒå®¢æˆ·ç¾¤ä½“çš„å¹³å‡è®¢å•ä»·å€¼å·®å¼‚ï¼Ÿ"),
            ],
            "åœ°åŸŸåˆ†æ": [
                (16, "å“ªäº›åœ°åŒºçš„å¸‚åœºæ¸—é€ç‡æœ€é«˜ï¼Ÿ"),
                (17, "ä¸åŒå›½å®¶/åŸå¸‚çš„æ¶ˆè´¹åå¥½æœ‰ä»€ä¹ˆå·®å¼‚ï¼Ÿ"),
                (18, "åœ°åŸŸæ‰©å¼ çš„ä¼˜å…ˆçº§æ’åºä¾æ®æ˜¯ä»€ä¹ˆï¼Ÿ"),
                (19, "è¿è¾“è·ç¦»å¯¹è®¢å•æˆæœ¬å’Œå®¢æˆ·æ»¡æ„åº¦çš„å½±å“ï¼Ÿ"),
                (20, "å„åœ°åŒºçš„å¸‚åœºé¥±å’Œåº¦å¦‚ä½•ï¼Ÿ"),
            ],
            "åº“å­˜ç®¡ç†åˆ†æ": [
                (21, "åº“å­˜å‘¨è½¬ç‡æœ€é«˜å’Œæœ€ä½çš„äº§å“åˆ†åˆ«æ˜¯å“ªäº›ï¼Ÿ"),
                (22, "ç¼ºè´§é¢‘ç‡æœ€é«˜çš„äº§å“åŠå…¶å½±å“ï¼Ÿ"),
                (23, "å®‰å…¨åº“å­˜è®¾ç½®æ˜¯å¦åˆç†ï¼Ÿè¿‡é‡åº“å­˜æˆæœ¬å¤šå°‘ï¼Ÿ"),
                (24, "ä¾›åº”å•†äº¤è´§åŠæ—¶æ€§å¦‚ä½•ï¼Ÿå“ªå®¶ä¾›åº”å•†æœ€å¯é ï¼Ÿ"),
                (25, "Lead Timeå¯¹åº“å­˜æˆæœ¬çš„å½±å“åˆ†æï¼Ÿ"),
            ],
            "å‘˜å·¥ç»©æ•ˆåˆ†æ": [
                (26, "é”€å”®å‘˜å·¥çš„ä¸šç»©æ’ååŠå·®å¼‚åŸå› ï¼Ÿ"),
                (27, "å‘˜å·¥çš„å®¢æˆ·ç»´æŠ¤èƒ½åŠ›å¦‚ä½•è¯„ä¼°ï¼Ÿ"),
                (28, "ä¸åŒå‘˜å·¥è´Ÿè´£çš„å®¢æˆ·ç¾¤ä½“æœ‰ä»€ä¹ˆç‰¹å¾ï¼Ÿ"),
                (29, "å‘˜å·¥åŸ¹è®­æŠ•å…¥ä¸ä¸šç»©æå‡çš„ç›¸å…³æ€§ï¼Ÿ"),
                (30, "å›¢é˜Ÿåä½œå¯¹æ•´ä½“é”€å”®çš„å½±å“ï¼Ÿ"),
            ],
            "ç›ˆåˆ©èƒ½åŠ›åˆ†æ": [
                (31, "æ¯›åˆ©ç‡æœ€é«˜çš„äº§å“ç±»åˆ«å’Œå®¢æˆ·ç¾¤ä½“ï¼Ÿ"),
                (32, "è¿è¾“æˆæœ¬å æ€»æˆæœ¬çš„æ¯”ä¾‹åŠä¼˜åŒ–ç©ºé—´ï¼Ÿ"),
                (33, "ä¸åŒé”€å”®æ¸ é“çš„æŠ•èµ„å›æŠ¥ç‡å¯¹æ¯”ï¼Ÿ"),
                (34, "åº”æ”¶è´¦æ¬¾å‘¨è½¬æƒ…å†µåŠä¿¡ç”¨é£é™©è¯„ä¼°ï¼Ÿ"),
                (35, "æŠ˜æ‰£ç­–ç•¥å¯¹æ•´ä½“åˆ©æ¶¦çš„å½±å“ï¼Ÿ"),
            ],
            "æˆæœ¬æ§åˆ¶åˆ†æ": [
                (36, "å•ä½è·å®¢æˆæœ¬è¶‹åŠ¿åŠä¼˜åŒ–å»ºè®®ï¼Ÿ"),
                (37, "ç‰©æµæˆæœ¬vsé”€å”®é¢çš„æ¯”ä¾‹å˜åŒ–ï¼Ÿ"),
                (38, "å“ªäº›ç¯èŠ‚çš„æˆæœ¬æ§åˆ¶æ•ˆæœæœ€æ˜æ˜¾ï¼Ÿ"),
                (39, "ä¾›åº”å•†ä»·æ ¼æ³¢åŠ¨å¯¹æˆæœ¬çš„å½±å“ï¼Ÿ"),
                (40, "è§„æ¨¡ç»æµæ•ˆåº”åœ¨å“ªäº›æ–¹é¢ä½“ç°æœ€æ˜æ˜¾ï¼Ÿ"),
            ],
            "ç«äº‰åˆ†æ": [
                (41, "å¸‚åœºä»½é¢å˜åŒ–è¶‹åŠ¿åŠç«äº‰æ€åŠ¿ï¼Ÿ"),
                (42, "ä»·æ ¼ç«äº‰åŠ›åˆ†æï¼šæˆ‘ä»¬çš„å®šä»·ç­–ç•¥å¦‚ä½•ï¼Ÿ"),
                (43, "äº§å“å·®å¼‚åŒ–ç¨‹åº¦åŠç«äº‰ä¼˜åŠ¿ï¼Ÿ"),
                (44, "å®¢æˆ·å¿ è¯šåº¦ä¸ç«äº‰å¯¹æ‰‹æ¯”è¾ƒï¼Ÿ"),
                (45, "æ–°äº§å“ä¸Šå¸‚æˆåŠŸç‡åŠå¸‚åœºæ¥å—åº¦ï¼Ÿ"),
            ],
            "è¶‹åŠ¿é¢„æµ‹": [
                (46, "åŸºäºå†å²æ•°æ®ï¼Œä¸‹å­£åº¦é”€å”®é¢„æµ‹ï¼Ÿ"),
                (47, "å“ªäº›äº§å“éœ€è¦æå‰å¤‡è´§ï¼Ÿæ•°é‡å¤šå°‘ï¼Ÿ"),
                (48, "å®¢æˆ·éœ€æ±‚å˜åŒ–è¶‹åŠ¿åŠåº”å¯¹ç­–ç•¥ï¼Ÿ"),
                (49, "æ–°å…´å¸‚åœºçš„å¢é•¿æ½œåŠ›è¯„ä¼°ï¼Ÿ"),
                (50, "ä¾›åº”é“¾ä¸­æ–­é£é™©åŠåº”æ€¥é¢„æ¡ˆï¼Ÿ"),
            ],
            "æœåŠ¡è´¨é‡": [
                (51, "è®¢å•å¤„ç†æ—¶æ•ˆæ€§ç»Ÿè®¡åŠæ”¹è¿›ç‚¹ï¼Ÿ"),
                (52, "å®¢æˆ·æŠ•è¯‰ç‡åŠä¸»è¦é—®é¢˜åˆ†ç±»ï¼Ÿ"),
                (53, "é€€è´§ç‡æœ€é«˜çš„äº§å“åŠåŸå› åˆ†æï¼Ÿ"),
                (54, "ä¾›åº”å•†è´¨é‡è¯„ä¼°åŠæ”¹è¿›å»ºè®®ï¼Ÿ"),
                (55, "å®¢æˆ·æ»¡æ„åº¦è°ƒæŸ¥ç»“æœåŠæå‡æªæ–½ï¼Ÿ"),
            ],
            "æµç¨‹ä¼˜åŒ–": [
                (56, "è®¢å•-äº¤ä»˜å‘¨æœŸçš„ç“¶é¢ˆåœ¨å“ªé‡Œï¼Ÿ"),
                (57, "åº“å­˜è¡¥è´§é¢‘ç‡ä¼˜åŒ–å»ºè®®ï¼Ÿ"),
                (58, "è·¨éƒ¨é—¨åä½œæ•ˆç‡è¯„ä¼°ï¼Ÿ"),
                (59, "ä¿¡æ¯ç³»ç»Ÿä½¿ç”¨æ•ˆç‡åŠæ”¹è¿›ç©ºé—´ï¼Ÿ"),
                (60, "ä¸šåŠ¡æµç¨‹è‡ªåŠ¨åŒ–çš„æŠ•èµ„å›æŠ¥åˆ†æï¼Ÿ"),
            ]
        }
    
    def get_categories(self) -> List[str]:
        """è·å–æ‰€æœ‰é—®é¢˜åˆ†ç±»"""
        return list(self.questions.keys())
    
    def get_questions_by_category(self, category: str) -> List[Tuple[int, str]]:
        """æ ¹æ®åˆ†ç±»è·å–é—®é¢˜"""
        return self.questions.get(category, [])
    
    def get_random_questions(self, count: int = 5) -> List[Tuple[str, int, str]]:
        """è·å–éšæœºé—®é¢˜"""
        all_questions = []
        for category, questions in self.questions.items():
            for q_id, question in questions:
                all_questions.append((category, q_id, question))
        
        return random.sample(all_questions, min(count, len(all_questions)))
    
    def get_difficulty_questions(self, difficulty: str) -> List[Tuple[str, int, str]]:
        """æ ¹æ®éš¾åº¦è·å–é—®é¢˜"""
        difficulty_mapping = {
            "ç®€å•": ["æ—¶é—´ç»´åº¦åˆ†æ", "äº§å“ç»´åº¦åˆ†æ"],
            "ä¸­ç­‰": ["å®¢æˆ·ä»·å€¼åˆ†æ", "åœ°åŸŸåˆ†æ", "åº“å­˜ç®¡ç†åˆ†æ", "å‘˜å·¥ç»©æ•ˆåˆ†æ"],
            "å›°éš¾": ["ç›ˆåˆ©èƒ½åŠ›åˆ†æ", "æˆæœ¬æ§åˆ¶åˆ†æ", "ç«äº‰åˆ†æ", "è¶‹åŠ¿é¢„æµ‹", "æœåŠ¡è´¨é‡", "æµç¨‹ä¼˜åŒ–"]
        }
        
        categories = difficulty_mapping.get(difficulty, [])
        questions = []
        
        for category in categories:
            for q_id, question in self.questions.get(category, []):
                questions.append((category, q_id, question))
        
        return questions

def render_test_question_sidebar():
    """æ¸²æŸ“æµ‹è¯•é—®é¢˜ä¾§è¾¹æ """
    helper = TestQuestionHelper()
    
    with st.sidebar:
        st.markdown("---")
        st.subheader("ğŸ¯ æµ‹è¯•é—®é¢˜åŠ©æ‰‹")
        
        # é€‰æ‹©é—®é¢˜æ–¹å¼
        selection_method = st.selectbox(
            "é€‰æ‹©é—®é¢˜æ–¹å¼",
            ["æŒ‰åˆ†ç±»é€‰æ‹©", "éšæœºé€‰æ‹©", "æŒ‰éš¾åº¦é€‰æ‹©"]
        )
        
        selected_question = None
        
        if selection_method == "æŒ‰åˆ†ç±»é€‰æ‹©":
            category = st.selectbox("é€‰æ‹©åˆ†ç±»", helper.get_categories())
            questions = helper.get_questions_by_category(category)
            
            if questions:
                question_options = [f"{q_id}. {question}" for q_id, question in questions]
                selected_option = st.selectbox("é€‰æ‹©é—®é¢˜", question_options)
                
                if selected_option:
                    # æå–é—®é¢˜æ–‡æœ¬
                    selected_question = selected_option.split(". ", 1)[1]
        
        elif selection_method == "éšæœºé€‰æ‹©":
            count = st.slider("éšæœºé—®é¢˜æ•°é‡", 1, 10, 5)
            if st.button("ğŸ² ç”Ÿæˆéšæœºé—®é¢˜"):
                random_questions = helper.get_random_questions(count)
                
                st.write("**éšæœºé—®é¢˜ï¼š**")
                for i, (cat, q_id, question) in enumerate(random_questions, 1):
                    if st.button(f"{i}. {question[:30]}...", key=f"random_{i}"):
                        selected_question = question
        
        elif selection_method == "æŒ‰éš¾åº¦é€‰æ‹©":
            difficulty = st.selectbox("é€‰æ‹©éš¾åº¦", ["ç®€å•", "ä¸­ç­‰", "å›°éš¾"])
            questions = helper.get_difficulty_questions(difficulty)
            
            if questions:
                # éšæœºæ˜¾ç¤º5ä¸ªè¯¥éš¾åº¦çš„é—®é¢˜
                sample_questions = random.sample(questions, min(5, len(questions)))
                
                st.write(f"**{difficulty}é—®é¢˜ï¼š**")
                for i, (cat, q_id, question) in enumerate(sample_questions, 1):
                    if st.button(f"{q_id}. {question[:30]}...", key=f"diff_{i}"):
                        selected_question = question
        
        # å¿«é€Ÿè¾“å…¥æŒ‰é’®
        if selected_question and st.button("ğŸ“ å¿«é€Ÿè¾“å…¥", type="primary"):
            # è¿™é‡Œéœ€è¦ä¸ä¸»èŠå¤©ç•Œé¢é›†æˆ
            # å°†é€‰ä¸­çš„é—®é¢˜è®¾ç½®åˆ°è¾“å…¥æ¡†ä¸­
            st.session_state.selected_test_question = selected_question
            st.success("é—®é¢˜å·²é€‰æ‹©ï¼Œè¯·åœ¨èŠå¤©æ¡†ä¸­æŸ¥çœ‹")
        
        # æ˜¾ç¤ºé—®é¢˜ç»Ÿè®¡
        st.markdown("---")
        st.markdown("**ğŸ“Š é—®é¢˜åº“ç»Ÿè®¡**")
        total_questions = sum(len(questions) for questions in helper.questions.values())
        st.metric("æ€»é—®é¢˜æ•°", total_questions)
        st.metric("åˆ†ç±»æ•°", len(helper.questions))

def get_test_question_input():
    """è·å–æµ‹è¯•é—®é¢˜è¾“å…¥ï¼ˆç”¨äºä¸»èŠå¤©ç•Œé¢ï¼‰"""
    if "selected_test_question" in st.session_state:
        question = st.session_state.selected_test_question
        del st.session_state.selected_test_question  # æ¸…é™¤çŠ¶æ€
        return question
    return None